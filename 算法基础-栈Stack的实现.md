# 算法基础-栈(Stack)的实现

## 1. 栈的定义和准备知识

**栈(Stack)** 这种数据结构本质上是一种**限定只能在表尾进行插入和删除操作**的线性表

栈又称**先进后出(LIFO)**的线性表, 简称**LIFO**结构. 

**首先栈是一个线性表,也就是说栈元素具有线性关系, 即前驱后继关系.只不过它是一种特殊的线性表而已**  

在使用栈这种数据结构的时候我们应该清楚几件事:  

​        **1. 把允许插入和删除的一端称为栈顶(top)**.   **栈就是线性表, 把表尾作为栈顶**

​	**2.把另一端呢称为栈底**.

​	3.栈对线性表的插入和删除的位置进行了限制,但是要明白**它并没有对元素进出的时间进行限制**

由于栈本身就是一个线性表,那么我们讨论的线性表的顺序存储和链式存储, 对于栈来说,**也同样适用**

接下来就开始对栈的抽象了

## 2. 栈的抽象数据类型

**什么都不是一蹴而就的**, 这种深刻体会体现在**从无到有的演变过程**当中.**所谓"道生一 ,  一生二,  三生万物".**

在栈的定义时就明白, 昂,对呀~,把链表堵住一个口就是栈,链表有什么属性和操作那么对于栈来说也有?**答案当然是**

废话不多说,开始来真的

对于抽象数据类型, 将数据和对数据的操作进行抽象,设计合理的 API....., 一堆的设计(很复杂)

``` 
ADT 栈(stack)
Data
	同线性表.元素具有相同的类型,相邻元素具有前驱和后继关系
operation
	Initstack(*S);       //初始化操作, 建立一个空栈 S
	DestroyStack(*S);    //若栈存在, 则销毁它
	ClearStack(*S);	     //将栈清空
	StackEmpty(*S);      //若栈为空, 返回 true,否则返回 false
	GetTop(S,*e);		//若栈存在且非空, 用 e 返回 S 的栈顶元素
	Push(*S,e);			//若栈存在, 插入新元素 e 到栈 S 中并成为栈顶元素
    Pop(*S,*e);			//删除栈 S 中栈顶元素并用 e 返回其值
    StackLength(S);		//返回栈 S 的元素个数
```

## 3. 栈的顺序存储结构及实现

既然栈是线性表的特例, 那么栈的顺序存储其实也是线性表顺序存储的简化, **简称顺序栈**

**线性表用数组实现, 将数组首元素作为栈底,若存储栈的长度为 stackSize, 则栈顶位置 top必须小于 stackSize**

**当存在一个元素时 top 等于 0** , **因此通常把空栈的判定条件定为 top 等于 -1**

栈的结构定义(c语言)

```C
typedef int SElemType;  	/*SElemType 类型根据实际情况而定*/
typedef struct{
  SElemtype data[MAXSIZE];	/*可以理解为整个栈就是一个数组,只是增删要在数组的末端进行*/
  int top;   			   /*用于栈顶指针*/
}
```

结构定义(java)

```java
public class Stack{
  private String[] a;   //这里的数组可以为任意类型,要加入泛型
  private int top;	    //用于栈顶指针
}
```



## 4. 栈的链式存储结构及实现

结构定义(c语言)

```c

```



结构定义(java):为了是这个定义使用与所有的数据类型,在定义时使用泛型,**线性表数据元素结点的定义为内部类**

在使用内部类的时候,首先要清楚两个**重要的知识点:**

**1. 私有内部类, 只有包含它的类才能够直接访问它的实例变量**

**2. 内部类可以访问包含它的类的实例变量**

```java
public class Stack<Item> implements Iterable<Item> {
	private Node<Item> first;	//栈的top	
	private int n;	//栈的大小
	/**
	 * 定义结点数据类型, 可接收泛型
	 * @author 邢峻华
	 * @param <Item>
	 */
	private static class Node<Item>{
		private Item item;   //存储结点中的数据,在栈的抽象数据类型中定义结点
		private Node next;	 //后继结点的引用(地址)
	}
  	......
    ..操作数据的方法
    ......
}
```



​	